# Lab 5

## 1. In the file data.py the list packets contains 1000 messages (portuguese ASCII) enciphered by a stream cipher. We know that some of those messages were enciphered using the same key stream. Can you identify them?


If two messages ``a = a0 + a1 + a2`` and ``b = b0 + b1 + b2`` are encrypted using the keystream generated by the same key and the same IV, the bits in the two ciphertexts are given by
```
C(a0) = a0 XOR k
C(b0) = b0 XOR k
```

Combining the two equations gives us:
```
C(a0) XOR C(b0) = a0 XOR b0
```

Also, if only the portuguese ASCII characteres were used , this means that ``a0 XOR b0`` should not be greater than 128 (size of ASCII table) in order to be the same key stream enchipered text.

Finally, if we perform a script that validates the resulted XOR, for instance, of each character of a given message ``a`` with message ``b`` and the result is never greater than 128, than the same keystream was used.

The following python script does the upper.

```
from data import *

## This function returns if 2 packets use the same keystream
def have_same_ks(packet1, packet2):
    zip_tuple = zip(packet1,packet2)
    for x in zip_tuple:
        if(int(x[0] ^ x[1]) > 128):
            print("They have NOT the same KS")
            return False
    #print("They have the same KS")
    return True
    
## Main

packets_same_ks = []

for a in range(0, len(packets)):
    for b in range(a+1, len(packets)):
        if(have_same_ks(packets[a], packets[b])):
            packets_same_ks.append(a)
            packets_same_ks.append(b)
        
print(packets_same_ks)

```
---


## 2. Alice and Bob agree to communicate privately via email using a scheme based on RC4, but they want to avoid using a new secret key for each transmission. Alice and Bob privately agree on a 128-bit key k. To encrypt a message m, consisting of a string of bits, the following procedure is used.

### i - Choose a random 80-bit value ``v``.

### ii - Generate the ciphertext ``c = RC4(v · k) ⊕ m``, where · denotes the concatenation.

### iii - Send the bit string ``(v · c)``

### (a) Suppose Alice uses this procedure to send a message m to Bob. Describe how Bob can recover the message m from (v · c) using k.

Given that Bob already has ``k`` and ``(v · c)`` given by Alice, than it is easy to calculate that if ``c = RC4(v · k) ⊕ m`` , than ``m = RC4(v · k) ⊕ c`` , because the inverse of a XOR is also the XOR.

### (b) If an adversary observes several values (v1 · c1), (v2 · c2), . . . transmitted between Alice and Bob, how can he determine when the same key stream has been used to encrypt two messages?

When a nounce is used multiple times with the same key, this produces identical keystreams, so the messages shoud have the same v.

### (c) Approximately how many messages can Alice expect to send before the same key stream will be used twice?

In this case , the keystream depends merely on the vale of ``v`` , so , ``2 ^ (80/2) = 2 ^ 40```


### (e) How many messages should Alice use the key k, before generating another?

Using a differnte key every time is the optimal solution, however, since they don't want that, she could send up to approximately ``2^40`` message until a possible collision happens.
# Lab 5

## 1. In the file data.py the list packets contains 1000 messages (portuguese ASCII) enciphered by a stream cipher. We know that some of those messages were enciphered using the same key stream. Can you identify them?


If two messages ``a = a0 + a1 + a2`` and ``b = b0 + b1 + b2`` are encrypted using the keystream generated by the same key and the same IV, the bits in the two ciphertexts are given by
```
C(a0) = a0 XOR k
C(b0) = b0 XOR k
```

Combining the two equations gives us:
```
C(a0) XOR C(b0) = a0 XOR b0
```

Also, if only the portuguese ASCII characteres were used , this means that ``a0 XOR b0`` should not be greater than 128 (size of ASCII table) in order to be the same key stream enchipered text.

Finally, if we perform a script that validates the resulted XOR, for instance, of each character of a given message ``a`` with message ``b`` and the result is never greater than 128, than the same keystream was used.

The following python script does the upper.

```
from data import *

## This function returns if 2 packets use the same keystream
def have_same_ks(packet1, packet2):
    zip_tuple = zip(packet1,packet2)
    for x in zip_tuple:
        if(int(x[0] ^ x[1]) > 128):
            print("They have NOT the same KS")
            return False
    #print("They have the same KS")
    return True
    
## Main

packets_same_ks = []

for a in range(0, len(packets)):
    for b in range(a+1, len(packets)):
        if(have_same_ks(packets[a], packets[b])):
            packets_same_ks.append(a)
            packets_same_ks.append(b)
        
print(packets_same_ks)

```
---


## 2. Alice and Bob agree to communicate privately via email using a scheme based on RC4, but they want to avoid using a new secret key for each transmission. Alice and Bob privately agree on a 128-bit key k. To encrypt a message m, consisting of a string of bits, the following procedure is used.

### i - Choose a random 80-bit value ``v``.

### ii - Generate the ciphertext ``c = RC4(v · k) ⊕ m``, where · denotes the concatenation.

### iii - Send the bit string ``(v · c)``

### (a) Suppose Alice uses this procedure to send a message m to Bob. Describe how Bob can recover the message m from (v · c) using k.

Given that Bob already has ``k`` and ``(v · c)`` given by Alice, than it is easy to calculate that if ``c = RC4(v · k) ⊕ m`` , than ``m = RC4(v · k) ⊕ c`` , because the inverse of a XOR is also the XOR.

### (b) If an adversary observes several values (v1 · c1), (v2 · c2), . . . transmitted between Alice and Bob, how can he determine when the same key stream has been used to encrypt two messages?

When a nounce is used multiple times with the same key, this produces identical keystreams, so the messages shoud have the same v.

### (c) Approximately how many messages can Alice expect to send before the same key stream will be used twice?

In this case , the keystream depends merely on the vale of ``v`` , so , ``2 ^ (80/2) = 2 ^ 40```


### (e) How many messages should Alice use the key k, before generating another?

Using a differnte key every time is the optimal solution, however, since they don't want that, she could send up to approximately ``2^40`` message until a possible collision happens.